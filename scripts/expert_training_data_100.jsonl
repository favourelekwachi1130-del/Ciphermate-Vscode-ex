{
  "sample_id": "VULN-LOGIC-29441",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "go"
  ],
  "domain": "authentication",
  "attack_surface": [
    "api",
    "database"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Crypto Timing Attack - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-77693",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Exploit spans multiple requests",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-LOGIC-31408",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "privilege_escalation_via_state",
  "language": [
    "javascript"
  ],
  "domain": "authorization",
  "attack_surface": [
    "api"
  ],
  "cwe": [
    "CWE-269",
    "CWE-284"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "admin.py",
      "role": "mutator",
      "code": "def promote_user(user_id, new_role):\n    user = User.objects.get(id=user_id)\n    \n    # Update role first\n    user.role = new_role\n    user.save()\n    \n    # Then check if current user has permission\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        # Rollback (but already mutated!)\n        user.role = user.previous_role\n        user.save()\n        raise PermissionDenied()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "rbac.py",
      "role": "supporting",
      "code": "def get_current_user():\n    return request.user\n\ndef log_admin_action(admin, action):\n    AdminLog.objects.create(\n        admin=admin,\n        action=action,\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Privilege Escalation Via State - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization check exists",
    "Requires runtime state",
    "State mutation before check",
    "Requires trust-boundary reasoning"
  ],
  "contrastive_pair_id": "PAIR-69917",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has limited user account",
    "step_1": "Trigger privilege change request",
    "step_2": "State mutated before permission check",
    "step_3": "Exploit rollback or race condition",
    "result": "Unauthorized privilege escalation"
  },
  "expert_characteristics": [
    "Exploit spans multiple requests",
    "Requires trust-boundary reasoning"
  ]
}

{
  "sample_id": "VULN-RACE-63638",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "java"
  ],
  "domain": "wallet",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Idempotency Violation - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-42941",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Exploit spans multiple services",
    "Requires runtime state"
  ]
}

{
  "sample_id": "VULN-RACE-42065",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "python"
  ],
  "domain": "wallet",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Check if already processed\n    existing = Payment.objects.filter(id=payment_id).first()\n    if existing and existing.status == 'completed':\n        return {\"status\": \"already_processed\"}\n    \n    # Process payment\n    payment = Payment.objects.create(\n        id=payment_id,\n        amount=amount,\n        status='processing'\n    )\n    \n    # Deduct from account\n    account = get_account()\n    account.balance -= amount\n    account.save()\n    \n    payment.status = 'completed'\n    payment.save()\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Idempotency Violation - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": {
    "explanation": "Business logic bypass possible",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-68733",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Requires trust-boundary reasoning",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-RACE-85795",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "business_logic_bypass",
  "language": [
    "python"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "backend",
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "discount.py",
      "role": "entrypoint",
      "code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
    },
    {
      "snippet_id": "B",
      "file": "cart.py",
      "role": "supporting",
      "code": "def calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    return total"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Business Logic Bypass - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
  },
  "why_static_analysis_fails": [
    "Requires business context",
    "No syntax errors",
    "Logic appears correct",
    "Requires domain knowledge"
  ],
  "contrastive_pair_id": "PAIR-21463",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to discount codes",
    "step_1": "Apply discount code that appears valid",
    "step_2": "Bypass usage limits or eligibility checks",
    "step_3": "Stack multiple discounts or exploit timing",
    "result": "Unauthorized discount application or financial loss"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-RACE-14565",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "authorization_order_flaw",
  "language": [
    "python"
  ],
  "domain": "healthcare",
  "attack_surface": [
    "service"
  ],
  "cwe": [
    "CWE-840",
    "CWE-639"
  ],
  "owasp_2021": [
    "A04: Insecure Design",
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation",
      "Impact"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "transfer.py",
      "role": "mutator",
      "code": "def transfer_funds(from_account, to_account, amount):\n    # Update balance first\n    from_account.balance -= amount\n    to_account.balance += amount\n    \n    # Then check authorization\n    if not check_transfer_authorization(from_account, to_account, amount):\n        # Rollback (but already mutated!)\n        from_account.balance += amount\n        to_account.balance -= amount\n        raise UnauthorizedError()\n    \n    save_transaction(from_account, to_account, amount)\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "auth.py",
      "role": "validator",
      "code": "def check_transfer_authorization(from_account, to_account, amount):\n    if from_account.balance < amount:\n        return False\n    if from_account.is_frozen:\n        return False\n    return True"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Authorization Order Flaw - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": {
    "explanation": "Business logic bypass possible",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def transfer_funds(from_account, to_account, amount):\n    # Check authorization FIRST\n    if not check_transfer_authorization(from_account, to_account, amount):\n        raise UnauthorizedError()\n    \n    # Then update balance\n    from_account.balance -= amount\n    to_account.balance += amount\n    \n    save_transaction(from_account, to_account, amount)\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization function exists",
    "No missing checks at syntax level",
    "Requires temporal execution reasoning",
    "Order-of-operations vulnerability"
  ],
  "contrastive_pair_id": "PAIR-27307",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has authenticated account with limited balance",
    "step_1": "Initiate transfer request with insufficient funds",
    "step_2": "Balance is mutated before authorization check",
    "step_3": "Authorization fails but state already changed",
    "step_4": "Exploit rollback mechanism or race condition",
    "result": "Unauthorized fund transfer or balance manipulation"
  },
  "expert_characteristics": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-RACE-55039",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "business_logic_bypass",
  "language": [
    "ruby"
  ],
  "domain": "ecommerce",
  "attack_surface": [
    "api",
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "discount.py",
      "role": "entrypoint",
      "code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
    },
    {
      "snippet_id": "B",
      "file": "cart.py",
      "role": "supporting",
      "code": "def calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    return total"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Business Logic Bypass - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
  },
  "why_static_analysis_fails": [
    "Requires business context",
    "No syntax errors",
    "Logic appears correct",
    "Requires domain knowledge"
  ],
  "contrastive_pair_id": "PAIR-62881",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to discount codes",
    "step_1": "Apply discount code that appears valid",
    "step_2": "Bypass usage limits or eligibility checks",
    "step_3": "Stack multiple discounts or exploit timing",
    "result": "Unauthorized discount application or financial loss"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Exploit spans multiple requests",
    "Requires trust-boundary reasoning"
  ]
}

{
  "sample_id": "VULN-STATE-66793",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "race_condition_authorization",
  "language": [
    "python"
  ],
  "domain": "auction",
  "attack_surface": [
    "backend",
    "api"
  ],
  "cwe": [
    "CWE-362",
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def create_payment_record(user_id, amount):\n    Payment.objects.create(\n        user_id=user_id,\n        amount=amount,\n        status='completed',\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Race Condition Authorization - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-46658",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has account with balance X",
    "step_1": "Initiate multiple concurrent payment requests for amount > X",
    "step_2": "All requests pass balance check simultaneously",
    "step_3": "All requests process, bypassing balance validation",
    "result": "Overdraft or negative balance exploitation"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Requires trust-boundary reasoning",
    "Exploit spans multiple requests"
  ]
}

{
  "sample_id": "VULN-TRUST-50300",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "insecure_deserialization_order",
  "language": [
    "python"
  ],
  "domain": "api",
  "attack_surface": [
    "api",
    "backend"
  ],
  "cwe": [
    "CWE-502"
  ],
  "owasp_2021": [
    "A08: Software and Data Integrity Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Initial Access",
      "Execution"
    ],
    "technique": [
      "T1203"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Insecure Deserialization Order - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Deserialization looks safe",
    "Validation exists but in wrong order",
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ],
  "contrastive_pair_id": "PAIR-53534",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-LOGIC-19543",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "c"
  ],
  "domain": "api",
  "attack_surface": [
    "api"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Crypto Timing Attack - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-49442",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires business context",
    "Looks secure in isolation",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-RACE-19685",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "race_condition_authorization",
  "language": [
    "java"
  ],
  "domain": "trading",
  "attack_surface": [
    "database",
    "backend"
  ],
  "cwe": [
    "CWE-362",
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def create_payment_record(user_id, amount):\n    Payment.objects.create(\n        user_id=user_id,\n        amount=amount,\n        status='completed',\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Race Condition Authorization - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-84685",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has account with balance X",
    "step_1": "Initiate multiple concurrent payment requests for amount > X",
    "step_2": "All requests pass balance check simultaneously",
    "step_3": "All requests process, bypassing balance validation",
    "result": "Overdraft or negative balance exploitation"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Requires protocol understanding",
    "Requires trust-boundary reasoning"
  ]
}

{
  "sample_id": "VULN-TRUST-74422",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "business_logic_bypass",
  "language": [
    "ruby"
  ],
  "domain": "subscription",
  "attack_surface": [
    "backend",
    "service"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "discount.py",
      "role": "entrypoint",
      "code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
    },
    {
      "snippet_id": "B",
      "file": "cart.py",
      "role": "supporting",
      "code": "def calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    return total"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Business Logic Bypass - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
  },
  "why_static_analysis_fails": [
    "Requires business context",
    "No syntax errors",
    "Logic appears correct",
    "Requires domain knowledge"
  ],
  "contrastive_pair_id": "PAIR-93066",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to discount codes",
    "step_1": "Apply discount code that appears valid",
    "step_2": "Bypass usage limits or eligibility checks",
    "step_3": "Stack multiple discounts or exploit timing",
    "result": "Unauthorized discount application or financial loss"
  },
  "expert_characteristics": [
    "Requires attacker timing",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-LOGIC-17550",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "insecure_deserialization_order",
  "language": [
    "python"
  ],
  "domain": "distributed",
  "attack_surface": [
    "api"
  ],
  "cwe": [
    "CWE-502"
  ],
  "owasp_2021": [
    "A08: Software and Data Integrity Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Initial Access",
      "Execution"
    ],
    "technique": [
      "T1203"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Insecure Deserialization Order - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Deserialization looks safe",
    "Validation exists but in wrong order",
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ],
  "contrastive_pair_id": "PAIR-45430",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-AUTH-10436",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "trust_boundary_confusion",
  "language": [
    "python"
  ],
  "domain": "api_gateway",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-501",
    "CWE-290"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Lateral Movement"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Trust Boundary Confusion - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services",
    "No single point of failure",
    "Distributed system reasoning"
  ],
  "contrastive_pair_id": "PAIR-70595",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to one service",
    "step_1": "Exploit trust assumption in service A",
    "step_2": "Service A forwards request to service B",
    "step_3": "Service B trusts request from A",
    "result": "Lateral movement or privilege escalation"
  },
  "expert_characteristics": [
    "Requires business context",
    "Looks secure in isolation",
    "Requires runtime state",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-RACE-91937",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "insecure_deserialization_order",
  "language": [
    "python"
  ],
  "domain": "distributed",
  "attack_surface": [
    "api"
  ],
  "cwe": [
    "CWE-502"
  ],
  "owasp_2021": [
    "A08: Software and Data Integrity Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Initial Access",
      "Execution"
    ],
    "technique": [
      "T1203"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Insecure Deserialization Order - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": {
    "explanation": "Business logic bypass possible",
    "impact": "unauthorized fund transfer"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Deserialization looks safe",
    "Validation exists but in wrong order",
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ],
  "contrastive_pair_id": "PAIR-45430",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-AUTH-25795",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "business_logic_bypass",
  "language": [
    "ruby"
  ],
  "domain": "subscription",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "discount.py",
      "role": "entrypoint",
      "code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
    },
    {
      "snippet_id": "B",
      "file": "cart.py",
      "role": "supporting",
      "code": "def calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    return total"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Business Logic Bypass - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
  },
  "why_static_analysis_fails": [
    "Requires business context",
    "No syntax errors",
    "Logic appears correct",
    "Requires domain knowledge"
  ],
  "contrastive_pair_id": "PAIR-50280",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to discount codes",
    "step_1": "Apply discount code that appears valid",
    "step_2": "Bypass usage limits or eligibility checks",
    "step_3": "Stack multiple discounts or exploit timing",
    "result": "Unauthorized discount application or financial loss"
  },
  "expert_characteristics": [
    "Exploit spans multiple services",
    "Looks secure in isolation",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-LOGIC-14158",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "insecure_deserialization_order",
  "language": [
    "python"
  ],
  "domain": "api",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-502"
  ],
  "owasp_2021": [
    "A08: Software and Data Integrity Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Initial Access",
      "Execution"
    ],
    "technique": [
      "T1203"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Insecure Deserialization Order - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Deserialization looks safe",
    "Validation exists but in wrong order",
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ],
  "contrastive_pair_id": "PAIR-38634",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple requests",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-TRUST-29501",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "privilege_escalation_via_state",
  "language": [
    "javascript"
  ],
  "domain": "rbac",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-269",
    "CWE-284"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "admin.py",
      "role": "mutator",
      "code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "rbac.py",
      "role": "supporting",
      "code": "def get_current_user():\n    return request.user\n\ndef log_admin_action(admin, action):\n    AdminLog.objects.create(\n        admin=admin,\n        action=action,\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Privilege Escalation Via State - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization check exists",
    "Requires runtime state",
    "State mutation before check",
    "Requires trust-boundary reasoning"
  ],
  "contrastive_pair_id": "PAIR-75776",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has limited user account",
    "step_1": "Trigger privilege change request",
    "step_2": "State mutated before permission check",
    "step_3": "Exploit rollback or race condition",
    "result": "Unauthorized privilege escalation"
  },
  "expert_characteristics": [
    "Exploit spans multiple requests",
    "Requires attacker timing",
    "Requires business context",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-LOGIC-99653",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "python"
  ],
  "domain": "wallet",
  "attack_surface": [
    "backend",
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Check if already processed\n    existing = Payment.objects.filter(id=payment_id).first()\n    if existing and existing.status == 'completed':\n        return {\"status\": \"already_processed\"}\n    \n    # Process payment\n    payment = Payment.objects.create(\n        id=payment_id,\n        amount=amount,\n        status='processing'\n    )\n    \n    # Deduct from account\n    account = get_account()\n    account.balance -= amount\n    account.save()\n    \n    payment.status = 'completed'\n    payment.save()\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Idempotency Violation - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": {
    "explanation": "Business logic bypass possible",
    "impact": "unauthorized fund transfer"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-13461",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Exploit spans multiple requests",
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-TRUST-14369",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "c"
  ],
  "domain": "api",
  "attack_surface": [
    "api"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Crypto Timing Attack - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-49442",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires business context",
    "Looks secure in isolation",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-AUTH-98879",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "trust_boundary_confusion",
  "language": [
    "go"
  ],
  "domain": "api_gateway",
  "attack_surface": [
    "api",
    "database"
  ],
  "cwe": [
    "CWE-501",
    "CWE-290"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Lateral Movement"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Trust Boundary Confusion - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services",
    "No single point of failure",
    "Distributed system reasoning"
  ],
  "contrastive_pair_id": "PAIR-32749",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to one service",
    "step_1": "Exploit trust assumption in service A",
    "step_2": "Service A forwards request to service B",
    "step_3": "Service B trusts request from A",
    "result": "Lateral movement or privilege escalation"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-TRUST-60692",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "authorization_order_flaw",
  "language": [
    "python"
  ],
  "domain": "ecommerce",
  "attack_surface": [
    "backend",
    "database"
  ],
  "cwe": [
    "CWE-840",
    "CWE-639"
  ],
  "owasp_2021": [
    "A04: Insecure Design",
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation",
      "Impact"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "transfer.py",
      "role": "mutator",
      "code": "def transfer_funds(from_account, to_account, amount):\n    # Check authorization FIRST\n    if not check_transfer_authorization(from_account, to_account, amount):\n        raise UnauthorizedError()\n    \n    # Then update balance\n    from_account.balance -= amount\n    to_account.balance += amount\n    \n    save_transaction(from_account, to_account, amount)\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "auth.py",
      "role": "validator",
      "code": "def check_transfer_authorization(from_account, to_account, amount):\n    if from_account.balance < amount:\n        return False\n    if from_account.is_frozen:\n        return False\n    return True"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Authorization Order Flaw - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def transfer_funds(from_account, to_account, amount):\n    # Check authorization FIRST\n    if not check_transfer_authorization(from_account, to_account, amount):\n        raise UnauthorizedError()\n    \n    # Then update balance\n    from_account.balance -= amount\n    to_account.balance += amount\n    \n    save_transaction(from_account, to_account, amount)\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization function exists",
    "No missing checks at syntax level",
    "Requires temporal execution reasoning",
    "Order-of-operations vulnerability"
  ],
  "contrastive_pair_id": "PAIR-90115",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has authenticated account with limited balance",
    "step_1": "Initiate transfer request with insufficient funds",
    "step_2": "Balance is mutated before authorization check",
    "step_3": "Authorization fails but state already changed",
    "step_4": "Exploit rollback mechanism or race condition",
    "result": "Unauthorized fund transfer or balance manipulation"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Requires runtime state",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-RACE-71993",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "go"
  ],
  "domain": "cryptography",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Crypto Timing Attack - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-92498",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires business context",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-RACE-73532",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "business_logic_bypass",
  "language": [
    "javascript"
  ],
  "domain": "subscription",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "discount.py",
      "role": "entrypoint",
      "code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
    },
    {
      "snippet_id": "B",
      "file": "cart.py",
      "role": "supporting",
      "code": "def calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    return total"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Business Logic Bypass - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
  },
  "why_static_analysis_fails": [
    "Requires business context",
    "No syntax errors",
    "Logic appears correct",
    "Requires domain knowledge"
  ],
  "contrastive_pair_id": "PAIR-39012",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to discount codes",
    "step_1": "Apply discount code that appears valid",
    "step_2": "Bypass usage limits or eligibility checks",
    "step_3": "Stack multiple discounts or exploit timing",
    "result": "Unauthorized discount application or financial loss"
  },
  "expert_characteristics": [
    "Requires trust-boundary reasoning",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-AUTH-72920",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "privilege_escalation_via_state",
  "language": [
    "javascript"
  ],
  "domain": "admin",
  "attack_surface": [
    "api",
    "service"
  ],
  "cwe": [
    "CWE-269",
    "CWE-284"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "admin.py",
      "role": "mutator",
      "code": "def promote_user(user_id, new_role):\n    user = User.objects.get(id=user_id)\n    \n    # Update role first\n    user.role = new_role\n    user.save()\n    \n    # Then check if current user has permission\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        # Rollback (but already mutated!)\n        user.role = user.previous_role\n        user.save()\n        raise PermissionDenied()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "rbac.py",
      "role": "supporting",
      "code": "def get_current_user():\n    return request.user\n\ndef log_admin_action(admin, action):\n    AdminLog.objects.create(\n        admin=admin,\n        action=action,\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Privilege Escalation Via State - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Business logic bypass possible",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization check exists",
    "Requires runtime state",
    "State mutation before check",
    "Requires trust-boundary reasoning"
  ],
  "contrastive_pair_id": "PAIR-18643",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has limited user account",
    "step_1": "Trigger privilege change request",
    "step_2": "State mutated before permission check",
    "step_3": "Exploit rollback or race condition",
    "result": "Unauthorized privilege escalation"
  },
  "expert_characteristics": [
    "Exploit spans multiple services",
    "Requires attacker timing",
    "Requires business context",
    "Exploit spans multiple requests"
  ]
}

{
  "sample_id": "VULN-TRUST-64356",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "python"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Check if already processed\n    existing = Payment.objects.filter(id=payment_id).first()\n    if existing and existing.status == 'completed':\n        return {\"status\": \"already_processed\"}\n    \n    # Process payment\n    payment = Payment.objects.create(\n        id=payment_id,\n        amount=amount,\n        status='processing'\n    )\n    \n    # Deduct from account\n    account = get_account()\n    account.balance -= amount\n    account.save()\n    \n    payment.status = 'completed'\n    payment.save()\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Idempotency Violation - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": {
    "explanation": "Authorization check occurs after state mutation",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-37314",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-STATE-80516",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "trust_boundary_confusion",
  "language": [
    "java"
  ],
  "domain": "api_gateway",
  "attack_surface": [
    "backend",
    "database"
  ],
  "cwe": [
    "CWE-501",
    "CWE-290"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Lateral Movement"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Trust Boundary Confusion - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services",
    "No single point of failure",
    "Distributed system reasoning"
  ],
  "contrastive_pair_id": "PAIR-71378",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to one service",
    "step_1": "Exploit trust assumption in service A",
    "step_2": "Service A forwards request to service B",
    "step_3": "Service B trusts request from A",
    "result": "Lateral movement or privilege escalation"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Requires trust-boundary reasoning",
    "Requires attacker timing",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-RACE-31700",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "go"
  ],
  "domain": "cryptography",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Crypto Timing Attack - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Authorization check occurs after state mutation",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-35852",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Exploit spans multiple requests",
    "Exploit spans multiple services",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-AUTH-64607",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "business_logic_bypass",
  "language": [
    "ruby"
  ],
  "domain": "subscription",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "discount.py",
      "role": "entrypoint",
      "code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
    },
    {
      "snippet_id": "B",
      "file": "cart.py",
      "role": "supporting",
      "code": "def calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    return total"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Business Logic Bypass - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "unauthorized fund transfer"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
  },
  "why_static_analysis_fails": [
    "Requires business context",
    "No syntax errors",
    "Logic appears correct",
    "Requires domain knowledge"
  ],
  "contrastive_pair_id": "PAIR-50280",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to discount codes",
    "step_1": "Apply discount code that appears valid",
    "step_2": "Bypass usage limits or eligibility checks",
    "step_3": "Stack multiple discounts or exploit timing",
    "result": "Unauthorized discount application or financial loss"
  },
  "expert_characteristics": [
    "Exploit spans multiple services",
    "Looks secure in isolation",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-RACE-92729",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "go"
  ],
  "domain": "cryptography",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Crypto Timing Attack - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": {
    "explanation": "Business logic bypass possible",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-92498",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires business context",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-STATE-89794",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "privilege_escalation_via_state",
  "language": [
    "python"
  ],
  "domain": "authorization",
  "attack_surface": [
    "api"
  ],
  "cwe": [
    "CWE-269",
    "CWE-284"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "admin.py",
      "role": "mutator",
      "code": "def promote_user(user_id, new_role):\n    user = User.objects.get(id=user_id)\n    \n    # Update role first\n    user.role = new_role\n    user.save()\n    \n    # Then check if current user has permission\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        # Rollback (but already mutated!)\n        user.role = user.previous_role\n        user.save()\n        raise PermissionDenied()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "rbac.py",
      "role": "supporting",
      "code": "def get_current_user():\n    return request.user\n\ndef log_admin_action(admin, action):\n    AdminLog.objects.create(\n        admin=admin,\n        action=action,\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Privilege Escalation Via State - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization check exists",
    "Requires runtime state",
    "State mutation before check",
    "Requires trust-boundary reasoning"
  ],
  "contrastive_pair_id": "PAIR-94614",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has limited user account",
    "step_1": "Trigger privilege change request",
    "step_2": "State mutated before permission check",
    "step_3": "Exploit rollback or race condition",
    "result": "Unauthorized privilege escalation"
  },
  "expert_characteristics": [
    "Requires attacker timing",
    "Exploit spans multiple requests",
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-AUTH-79849",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "state_mutation_before_validation",
  "language": [
    "python"
  ],
  "domain": "banking",
  "attack_surface": [
    "api",
    "backend"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: State Mutation Before Validation - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires runtime state",
    "Validation exists but in wrong order",
    "State mutation before check",
    "Temporal reasoning required"
  ],
  "contrastive_pair_id": "PAIR-11185",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can trigger state changes",
    "step_1": "Trigger operation that mutates state",
    "step_2": "State changed before validation",
    "step_3": "Validation fails but state persists",
    "result": "Invalid state or unauthorized access"
  },
  "expert_characteristics": [
    "Requires attacker timing",
    "Exploit spans multiple requests",
    "Requires runtime state"
  ]
}

{
  "sample_id": "VULN-RACE-17275",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "business_logic_bypass",
  "language": [
    "ruby"
  ],
  "domain": "ecommerce",
  "attack_surface": [
    "api",
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "discount.py",
      "role": "entrypoint",
      "code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
    },
    {
      "snippet_id": "B",
      "file": "cart.py",
      "role": "supporting",
      "code": "def calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    return total"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Business Logic Bypass - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
  },
  "why_static_analysis_fails": [
    "Requires business context",
    "No syntax errors",
    "Logic appears correct",
    "Requires domain knowledge"
  ],
  "contrastive_pair_id": "PAIR-62881",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to discount codes",
    "step_1": "Apply discount code that appears valid",
    "step_2": "Bypass usage limits or eligibility checks",
    "step_3": "Stack multiple discounts or exploit timing",
    "result": "Unauthorized discount application or financial loss"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Exploit spans multiple requests",
    "Requires trust-boundary reasoning"
  ]
}

{
  "sample_id": "VULN-STATE-33142",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "state_mutation_before_validation",
  "language": [
    "python"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "database",
    "api"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: State Mutation Before Validation - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires runtime state",
    "Validation exists but in wrong order",
    "State mutation before check",
    "Temporal reasoning required"
  ],
  "contrastive_pair_id": "PAIR-68844",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can trigger state changes",
    "step_1": "Trigger operation that mutates state",
    "step_2": "State changed before validation",
    "step_3": "Validation fails but state persists",
    "result": "Invalid state or unauthorized access"
  },
  "expert_characteristics": [
    "Exploit spans multiple services",
    "Exploit spans multiple requests",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-AUTH-15236",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "business_logic_bypass",
  "language": [
    "ruby"
  ],
  "domain": "ecommerce",
  "attack_surface": [
    "service",
    "api"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "discount.py",
      "role": "entrypoint",
      "code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
    },
    {
      "snippet_id": "B",
      "file": "cart.py",
      "role": "supporting",
      "code": "def calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    return total"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Business Logic Bypass - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
  },
  "why_static_analysis_fails": [
    "Requires business context",
    "No syntax errors",
    "Logic appears correct",
    "Requires domain knowledge"
  ],
  "contrastive_pair_id": "PAIR-58276",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to discount codes",
    "step_1": "Apply discount code that appears valid",
    "step_2": "Bypass usage limits or eligibility checks",
    "step_3": "Stack multiple discounts or exploit timing",
    "result": "Unauthorized discount application or financial loss"
  },
  "expert_characteristics": [
    "Requires trust-boundary reasoning",
    "Requires runtime state"
  ]
}

{
  "sample_id": "VULN-LOGIC-81461",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "privilege_escalation_via_state",
  "language": [
    "java"
  ],
  "domain": "admin",
  "attack_surface": [
    "database",
    "service"
  ],
  "cwe": [
    "CWE-269",
    "CWE-284"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "admin.py",
      "role": "mutator",
      "code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "rbac.py",
      "role": "supporting",
      "code": "def get_current_user():\n    return request.user\n\ndef log_admin_action(admin, action):\n    AdminLog.objects.create(\n        admin=admin,\n        action=action,\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Privilege Escalation Via State - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization check exists",
    "Requires runtime state",
    "State mutation before check",
    "Requires trust-boundary reasoning"
  ],
  "contrastive_pair_id": "PAIR-45951",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has limited user account",
    "step_1": "Trigger privilege change request",
    "step_2": "State mutated before permission check",
    "step_3": "Exploit rollback or race condition",
    "result": "Unauthorized privilege escalation"
  },
  "expert_characteristics": [
    "Requires business context",
    "Requires trust-boundary reasoning"
  ]
}

{
  "sample_id": "VULN-AUTH-84197",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "go"
  ],
  "domain": "authentication",
  "attack_surface": [
    "api",
    "database"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Crypto Timing Attack - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-77693",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Exploit spans multiple requests",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-TRUST-77621",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "go"
  ],
  "domain": "authentication",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Crypto Timing Attack - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-93341",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Exploit spans multiple services",
    "Requires attacker timing",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-AUTH-53764",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "insecure_deserialization_order",
  "language": [
    "ruby"
  ],
  "domain": "distributed",
  "attack_surface": [
    "database",
    "api"
  ],
  "cwe": [
    "CWE-502"
  ],
  "owasp_2021": [
    "A08: Software and Data Integrity Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Initial Access",
      "Execution"
    ],
    "technique": [
      "T1203"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Insecure Deserialization Order - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Deserialization looks safe",
    "Validation exists but in wrong order",
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ],
  "contrastive_pair_id": "PAIR-68812",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Looks secure in isolation",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-AUTH-45210",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "python"
  ],
  "domain": "cryptography",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Crypto Timing Attack - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "unauthorized fund transfer"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-91124",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires attacker timing",
    "Requires trust-boundary reasoning",
    "Requires protocol understanding",
    "Requires runtime state"
  ]
}

{
  "sample_id": "VULN-AUTH-55565",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "race_condition_authorization",
  "language": [
    "java"
  ],
  "domain": "auction",
  "attack_surface": [
    "service",
    "api"
  ],
  "cwe": [
    "CWE-362",
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def create_payment_record(user_id, amount):\n    Payment.objects.create(\n        user_id=user_id,\n        amount=amount,\n        status='completed',\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Race Condition Authorization - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-85814",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has account with balance X",
    "step_1": "Initiate multiple concurrent payment requests for amount > X",
    "step_2": "All requests pass balance check simultaneously",
    "step_3": "All requests process, bypassing balance validation",
    "result": "Overdraft or negative balance exploitation"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Requires trust-boundary reasoning"
  ]
}

{
  "sample_id": "VULN-AUTH-31228",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "python"
  ],
  "domain": "wallet",
  "attack_surface": [
    "service",
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Idempotency Violation - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-32397",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Requires business context",
    "Looks secure in isolation",
    "Requires trust-boundary reasoning",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-LOGIC-56579",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "race_condition_authorization",
  "language": [
    "java"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "api",
    "backend"
  ],
  "cwe": [
    "CWE-362",
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.get(id=user_id)\n    \n    # Check balance\n    if user.balance >= amount:\n        # Race window here - another request can modify balance\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def create_payment_record(user_id, amount):\n    Payment.objects.create(\n        user_id=user_id,\n        amount=amount,\n        status='completed',\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Race Condition Authorization - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-13712",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has account with balance X",
    "step_1": "Initiate multiple concurrent payment requests for amount > X",
    "step_2": "All requests pass balance check simultaneously",
    "step_3": "All requests process, bypassing balance validation",
    "result": "Overdraft or negative balance exploitation"
  },
  "expert_characteristics": [
    "Requires business context",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-TRUST-59824",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "race_condition_authorization",
  "language": [
    "python"
  ],
  "domain": "auction",
  "attack_surface": [
    "backend",
    "api"
  ],
  "cwe": [
    "CWE-362",
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.get(id=user_id)\n    \n    # Check balance\n    if user.balance >= amount:\n        # Race window here - another request can modify balance\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def create_payment_record(user_id, amount):\n    Payment.objects.create(\n        user_id=user_id,\n        amount=amount,\n        status='completed',\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Race Condition Authorization - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": {
    "explanation": "Business logic bypass possible",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-46658",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has account with balance X",
    "step_1": "Initiate multiple concurrent payment requests for amount > X",
    "step_2": "All requests pass balance check simultaneously",
    "step_3": "All requests process, bypassing balance validation",
    "result": "Overdraft or negative balance exploitation"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Requires trust-boundary reasoning",
    "Exploit spans multiple requests"
  ]
}

{
  "sample_id": "VULN-RACE-70108",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "time_of_check_time_of_use",
  "language": [
    "go"
  ],
  "domain": "database",
  "attack_surface": [
    "database",
    "api"
  ],
  "cwe": [
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Time Of Check Time Of Use - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Check exists but raceable",
    "TOCTOU vulnerability",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-57197",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can modify files between check and use",
    "step_1": "Application checks file permissions",
    "step_2": "Attacker modifies file during check-use window",
    "step_3": "Application uses modified file",
    "result": "Unauthorized file access or privilege escalation"
  },
  "expert_characteristics": [
    "Requires business context",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-AUTH-59763",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "business_logic_bypass",
  "language": [
    "ruby"
  ],
  "domain": "subscription",
  "attack_surface": [
    "backend",
    "service"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "discount.py",
      "role": "entrypoint",
      "code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
    },
    {
      "snippet_id": "B",
      "file": "cart.py",
      "role": "supporting",
      "code": "def calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    return total"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Business Logic Bypass - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
  },
  "why_static_analysis_fails": [
    "Requires business context",
    "No syntax errors",
    "Logic appears correct",
    "Requires domain knowledge"
  ],
  "contrastive_pair_id": "PAIR-93066",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to discount codes",
    "step_1": "Apply discount code that appears valid",
    "step_2": "Bypass usage limits or eligibility checks",
    "step_3": "Stack multiple discounts or exploit timing",
    "result": "Unauthorized discount application or financial loss"
  },
  "expert_characteristics": [
    "Requires attacker timing",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-AUTH-54923",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "authorization_order_flaw",
  "language": [
    "python"
  ],
  "domain": "healthcare",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-840",
    "CWE-639"
  ],
  "owasp_2021": [
    "A04: Insecure Design",
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation",
      "Impact"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "transfer.py",
      "role": "mutator",
      "code": "def transfer_funds(from_account, to_account, amount):\n    # Update balance first\n    from_account.balance -= amount\n    to_account.balance += amount\n    \n    # Then check authorization\n    if not check_transfer_authorization(from_account, to_account, amount):\n        # Rollback (but already mutated!)\n        from_account.balance += amount\n        to_account.balance -= amount\n        raise UnauthorizedError()\n    \n    save_transaction(from_account, to_account, amount)\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "auth.py",
      "role": "validator",
      "code": "def check_transfer_authorization(from_account, to_account, amount):\n    if from_account.balance < amount:\n        return False\n    if from_account.is_frozen:\n        return False\n    return True"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Authorization Order Flaw - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": {
    "explanation": "Authorization check occurs after state mutation",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def transfer_funds(from_account, to_account, amount):\n    # Check authorization FIRST\n    if not check_transfer_authorization(from_account, to_account, amount):\n        raise UnauthorizedError()\n    \n    # Then update balance\n    from_account.balance -= amount\n    to_account.balance += amount\n    \n    save_transaction(from_account, to_account, amount)\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization function exists",
    "No missing checks at syntax level",
    "Requires temporal execution reasoning",
    "Order-of-operations vulnerability"
  ],
  "contrastive_pair_id": "PAIR-56115",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has authenticated account with limited balance",
    "step_1": "Initiate transfer request with insufficient funds",
    "step_2": "Balance is mutated before authorization check",
    "step_3": "Authorization fails but state already changed",
    "step_4": "Exploit rollback mechanism or race condition",
    "result": "Unauthorized fund transfer or balance manipulation"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-AUTH-23761",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "session_fixation_via_state",
  "language": [
    "python"
  ],
  "domain": "web_app",
  "attack_surface": [
    "backend",
    "service"
  ],
  "cwe": [
    "CWE-384",
    "CWE-613"
  ],
  "owasp_2021": [
    "A01: Broken Access Control",
    "A07: Identification and Authentication Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Initial Access",
      "Persistence"
    ],
    "technique": [
      "T1078",
      "T1550"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "auth.py",
      "role": "entrypoint",
      "code": "def login(username, password, session_id=None):\n    user = authenticate(username, password)\n    if not user:\n        raise AuthenticationError()\n    \n    # Always create new session, ignore provided ID\n    old_session = Session.objects.filter(id=session_id).first()\n    if old_session:\n        old_session.delete()  # Invalidate attacker's session\n    \n    session = create_new_session(user)\n    return {\"session_id\": session.id}"
    },
    {
      "snippet_id": "B",
      "file": "session.py",
      "role": "supporting",
      "code": "def create_new_session(user):\n    session = Session.objects.create(\n        user=user,\n        token=generate_token(),\n        expires_at=timezone.now() + timedelta(days=7)\n    )\n    return session"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Session Fixation Via State - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def login(username, password, session_id=None):\n    user = authenticate(username, password)\n    if not user:\n        raise AuthenticationError()\n    \n    # Always create new session, ignore provided ID\n    old_session = Session.objects.filter(id=session_id).first()\n    if old_session:\n        old_session.delete()  # Invalidate attacker's session\n    \n    session = create_new_session(user)\n    return {\"session_id\": session.id}"
  },
  "why_static_analysis_fails": [
    "Requires runtime state",
    "Session management exists",
    "State mutation vulnerability",
    "Requires protocol understanding"
  ],
  "contrastive_pair_id": "PAIR-80224",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can obtain session ID before login",
    "step_1": "Obtain session ID from application",
    "step_2": "Provide session ID during login",
    "step_3": "Application reuses attacker's session",
    "result": "Attacker gains authenticated session"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-LOGIC-23098",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "race_condition_authorization",
  "language": [
    "java"
  ],
  "domain": "trading",
  "attack_surface": [
    "database",
    "backend"
  ],
  "cwe": [
    "CWE-362",
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.get(id=user_id)\n    \n    # Check balance\n    if user.balance >= amount:\n        # Race window here - another request can modify balance\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def create_payment_record(user_id, amount):\n    Payment.objects.create(\n        user_id=user_id,\n        amount=amount,\n        status='completed',\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Race Condition Authorization - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-84685",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has account with balance X",
    "step_1": "Initiate multiple concurrent payment requests for amount > X",
    "step_2": "All requests pass balance check simultaneously",
    "step_3": "All requests process, bypassing balance validation",
    "result": "Overdraft or negative balance exploitation"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Requires protocol understanding",
    "Requires trust-boundary reasoning"
  ]
}

{
  "sample_id": "VULN-TRUST-83003",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "session_fixation_via_state",
  "language": [
    "python"
  ],
  "domain": "web_app",
  "attack_surface": [
    "backend",
    "service"
  ],
  "cwe": [
    "CWE-384",
    "CWE-613"
  ],
  "owasp_2021": [
    "A01: Broken Access Control",
    "A07: Identification and Authentication Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Initial Access",
      "Persistence"
    ],
    "technique": [
      "T1078",
      "T1550"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "auth.py",
      "role": "entrypoint",
      "code": "def login(username, password, session_id=None):\n    user = authenticate(username, password)\n    if not user:\n        raise AuthenticationError()\n    \n    # Create session with provided ID (vulnerable!)\n    if session_id:\n        session = Session.objects.get(id=session_id)\n        session.user = user  # Attacker's session now has user\n        session.save()\n    else:\n        session = create_new_session(user)\n    \n    return {\"session_id\": session.id}"
    },
    {
      "snippet_id": "B",
      "file": "session.py",
      "role": "supporting",
      "code": "def create_new_session(user):\n    session = Session.objects.create(\n        user=user,\n        token=generate_token(),\n        expires_at=timezone.now() + timedelta(days=7)\n    )\n    return session"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Session Fixation Via State - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Authorization check occurs after state mutation",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def login(username, password, session_id=None):\n    user = authenticate(username, password)\n    if not user:\n        raise AuthenticationError()\n    \n    # Always create new session, ignore provided ID\n    old_session = Session.objects.filter(id=session_id).first()\n    if old_session:\n        old_session.delete()  # Invalidate attacker's session\n    \n    session = create_new_session(user)\n    return {\"session_id\": session.id}"
  },
  "why_static_analysis_fails": [
    "Requires runtime state",
    "Session management exists",
    "State mutation vulnerability",
    "Requires protocol understanding"
  ],
  "contrastive_pair_id": "PAIR-80224",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can obtain session ID before login",
    "step_1": "Obtain session ID from application",
    "step_2": "Provide session ID during login",
    "step_3": "Application reuses attacker's session",
    "result": "Attacker gains authenticated session"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-RACE-83677",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "python"
  ],
  "domain": "cryptography",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Crypto Timing Attack - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-91124",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires attacker timing",
    "Requires trust-boundary reasoning",
    "Requires protocol understanding",
    "Requires runtime state"
  ]
}

{
  "sample_id": "VULN-TRUST-27424",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "java"
  ],
  "domain": "wallet",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Check if already processed\n    existing = Payment.objects.filter(id=payment_id).first()\n    if existing and existing.status == 'completed':\n        return {\"status\": \"already_processed\"}\n    \n    # Process payment\n    payment = Payment.objects.create(\n        id=payment_id,\n        amount=amount,\n        status='processing'\n    )\n    \n    # Deduct from account\n    account = get_account()\n    account.balance -= amount\n    account.save()\n    \n    payment.status = 'completed'\n    payment.save()\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Idempotency Violation - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Business logic bypass possible",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-42941",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Exploit spans multiple services",
    "Requires runtime state"
  ]
}

{
  "sample_id": "VULN-AUTH-91887",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "trust_boundary_confusion",
  "language": [
    "go"
  ],
  "domain": "api_gateway",
  "attack_surface": [
    "api",
    "service"
  ],
  "cwe": [
    "CWE-501",
    "CWE-290"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Lateral Movement"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Trust Boundary Confusion - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services",
    "No single point of failure",
    "Distributed system reasoning"
  ],
  "contrastive_pair_id": "PAIR-64699",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to one service",
    "step_1": "Exploit trust assumption in service A",
    "step_2": "Service A forwards request to service B",
    "step_3": "Service B trusts request from A",
    "result": "Lateral movement or privilege escalation"
  },
  "expert_characteristics": [
    "Exploit spans multiple requests",
    "Requires protocol understanding",
    "Requires trust-boundary reasoning",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-RACE-23831",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "trust_boundary_confusion",
  "language": [
    "python"
  ],
  "domain": "api_gateway",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-501",
    "CWE-290"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Lateral Movement"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Trust Boundary Confusion - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services",
    "No single point of failure",
    "Distributed system reasoning"
  ],
  "contrastive_pair_id": "PAIR-70595",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to one service",
    "step_1": "Exploit trust assumption in service A",
    "step_2": "Service A forwards request to service B",
    "step_3": "Service B trusts request from A",
    "result": "Lateral movement or privilege escalation"
  },
  "expert_characteristics": [
    "Requires business context",
    "Looks secure in isolation",
    "Requires runtime state",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-RACE-61059",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "privilege_escalation_via_state",
  "language": [
    "javascript"
  ],
  "domain": "admin",
  "attack_surface": [
    "api",
    "service"
  ],
  "cwe": [
    "CWE-269",
    "CWE-284"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "admin.py",
      "role": "mutator",
      "code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "rbac.py",
      "role": "supporting",
      "code": "def get_current_user():\n    return request.user\n\ndef log_admin_action(admin, action):\n    AdminLog.objects.create(\n        admin=admin,\n        action=action,\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Privilege Escalation Via State - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization check exists",
    "Requires runtime state",
    "State mutation before check",
    "Requires trust-boundary reasoning"
  ],
  "contrastive_pair_id": "PAIR-18643",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has limited user account",
    "step_1": "Trigger privilege change request",
    "step_2": "State mutated before permission check",
    "step_3": "Exploit rollback or race condition",
    "result": "Unauthorized privilege escalation"
  },
  "expert_characteristics": [
    "Exploit spans multiple services",
    "Requires attacker timing",
    "Requires business context",
    "Exploit spans multiple requests"
  ]
}

{
  "sample_id": "VULN-RACE-26440",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "privilege_escalation_via_state",
  "language": [
    "javascript"
  ],
  "domain": "rbac",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-269",
    "CWE-284"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "admin.py",
      "role": "mutator",
      "code": "def promote_user(user_id, new_role):\n    user = User.objects.get(id=user_id)\n    \n    # Update role first\n    user.role = new_role\n    user.save()\n    \n    # Then check if current user has permission\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        # Rollback (but already mutated!)\n        user.role = user.previous_role\n        user.save()\n        raise PermissionDenied()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "rbac.py",
      "role": "supporting",
      "code": "def get_current_user():\n    return request.user\n\ndef log_admin_action(admin, action):\n    AdminLog.objects.create(\n        admin=admin,\n        action=action,\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Privilege Escalation Via State - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization check exists",
    "Requires runtime state",
    "State mutation before check",
    "Requires trust-boundary reasoning"
  ],
  "contrastive_pair_id": "PAIR-75776",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has limited user account",
    "step_1": "Trigger privilege change request",
    "step_2": "State mutated before permission check",
    "step_3": "Exploit rollback or race condition",
    "result": "Unauthorized privilege escalation"
  },
  "expert_characteristics": [
    "Exploit spans multiple requests",
    "Requires attacker timing",
    "Requires business context",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-TRUST-91347",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "race_condition_authorization",
  "language": [
    "java"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "service",
    "backend"
  ],
  "cwe": [
    "CWE-362",
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def create_payment_record(user_id, amount):\n    Payment.objects.create(\n        user_id=user_id,\n        amount=amount,\n        status='completed',\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Race Condition Authorization - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-49610",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has account with balance X",
    "step_1": "Initiate multiple concurrent payment requests for amount > X",
    "step_2": "All requests pass balance check simultaneously",
    "step_3": "All requests process, bypassing balance validation",
    "result": "Overdraft or negative balance exploitation"
  },
  "expert_characteristics": [
    "Exploit spans multiple services",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-LOGIC-61657",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "business_logic_bypass",
  "language": [
    "python"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "backend",
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "discount.py",
      "role": "entrypoint",
      "code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
    },
    {
      "snippet_id": "B",
      "file": "cart.py",
      "role": "supporting",
      "code": "def calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    return total"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Business Logic Bypass - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
  },
  "why_static_analysis_fails": [
    "Requires business context",
    "No syntax errors",
    "Logic appears correct",
    "Requires domain knowledge"
  ],
  "contrastive_pair_id": "PAIR-21463",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to discount codes",
    "step_1": "Apply discount code that appears valid",
    "step_2": "Bypass usage limits or eligibility checks",
    "step_3": "Stack multiple discounts or exploit timing",
    "result": "Unauthorized discount application or financial loss"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-STATE-64052",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "privilege_escalation_via_state",
  "language": [
    "javascript"
  ],
  "domain": "authorization",
  "attack_surface": [
    "api"
  ],
  "cwe": [
    "CWE-269",
    "CWE-284"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "admin.py",
      "role": "mutator",
      "code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "rbac.py",
      "role": "supporting",
      "code": "def get_current_user():\n    return request.user\n\ndef log_admin_action(admin, action):\n    AdminLog.objects.create(\n        admin=admin,\n        action=action,\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Privilege Escalation Via State - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization check exists",
    "Requires runtime state",
    "State mutation before check",
    "Requires trust-boundary reasoning"
  ],
  "contrastive_pair_id": "PAIR-69917",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has limited user account",
    "step_1": "Trigger privilege change request",
    "step_2": "State mutated before permission check",
    "step_3": "Exploit rollback or race condition",
    "result": "Unauthorized privilege escalation"
  },
  "expert_characteristics": [
    "Exploit spans multiple requests",
    "Requires trust-boundary reasoning"
  ]
}

{
  "sample_id": "VULN-STATE-93663",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "privilege_escalation_via_state",
  "language": [
    "python"
  ],
  "domain": "authorization",
  "attack_surface": [
    "api"
  ],
  "cwe": [
    "CWE-269",
    "CWE-284"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "admin.py",
      "role": "mutator",
      "code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "rbac.py",
      "role": "supporting",
      "code": "def get_current_user():\n    return request.user\n\ndef log_admin_action(admin, action):\n    AdminLog.objects.create(\n        admin=admin,\n        action=action,\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Privilege Escalation Via State - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization check exists",
    "Requires runtime state",
    "State mutation before check",
    "Requires trust-boundary reasoning"
  ],
  "contrastive_pair_id": "PAIR-94614",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has limited user account",
    "step_1": "Trigger privilege change request",
    "step_2": "State mutated before permission check",
    "step_3": "Exploit rollback or race condition",
    "result": "Unauthorized privilege escalation"
  },
  "expert_characteristics": [
    "Requires attacker timing",
    "Exploit spans multiple requests",
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-LOGIC-80723",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "python"
  ],
  "domain": "api",
  "attack_surface": [
    "service"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Crypto Timing Attack - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": {
    "explanation": "Authorization check occurs after state mutation",
    "impact": "unauthorized fund transfer"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-65957",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-STATE-14383",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "time_of_check_time_of_use",
  "language": [
    "go"
  ],
  "domain": "database",
  "attack_surface": [
    "database",
    "api"
  ],
  "cwe": [
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Time Of Check Time Of Use - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Check exists but raceable",
    "TOCTOU vulnerability",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-57197",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can modify files between check and use",
    "step_1": "Application checks file permissions",
    "step_2": "Attacker modifies file during check-use window",
    "step_3": "Application uses modified file",
    "result": "Unauthorized file access or privilege escalation"
  },
  "expert_characteristics": [
    "Requires business context",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-STATE-98457",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "insecure_deserialization_order",
  "language": [
    "python"
  ],
  "domain": "api",
  "attack_surface": [
    "api",
    "backend"
  ],
  "cwe": [
    "CWE-502"
  ],
  "owasp_2021": [
    "A08: Software and Data Integrity Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Initial Access",
      "Execution"
    ],
    "technique": [
      "T1203"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Insecure Deserialization Order - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": {
    "explanation": "Business logic bypass possible",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Deserialization looks safe",
    "Validation exists but in wrong order",
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ],
  "contrastive_pair_id": "PAIR-53534",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-LOGIC-72108",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "python"
  ],
  "domain": "wallet",
  "attack_surface": [
    "service",
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Check if already processed\n    existing = Payment.objects.filter(id=payment_id).first()\n    if existing and existing.status == 'completed':\n        return {\"status\": \"already_processed\"}\n    \n    # Process payment\n    payment = Payment.objects.create(\n        id=payment_id,\n        amount=amount,\n        status='processing'\n    )\n    \n    # Deduct from account\n    account = get_account()\n    account.balance -= amount\n    account.save()\n    \n    payment.status = 'completed'\n    payment.save()\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Idempotency Violation - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": {
    "explanation": "Authorization check occurs after state mutation",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-32397",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Requires business context",
    "Looks secure in isolation",
    "Requires trust-boundary reasoning",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-LOGIC-54674",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "business_logic_bypass",
  "language": [
    "ruby"
  ],
  "domain": "ecommerce",
  "attack_surface": [
    "service",
    "api"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "discount.py",
      "role": "entrypoint",
      "code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
    },
    {
      "snippet_id": "B",
      "file": "cart.py",
      "role": "supporting",
      "code": "def calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    return total"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Business Logic Bypass - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
  },
  "why_static_analysis_fails": [
    "Requires business context",
    "No syntax errors",
    "Logic appears correct",
    "Requires domain knowledge"
  ],
  "contrastive_pair_id": "PAIR-58276",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to discount codes",
    "step_1": "Apply discount code that appears valid",
    "step_2": "Bypass usage limits or eligibility checks",
    "step_3": "Stack multiple discounts or exploit timing",
    "result": "Unauthorized discount application or financial loss"
  },
  "expert_characteristics": [
    "Requires trust-boundary reasoning",
    "Requires runtime state"
  ]
}

{
  "sample_id": "VULN-LOGIC-27969",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "trust_boundary_confusion",
  "language": [
    "java"
  ],
  "domain": "api_gateway",
  "attack_surface": [
    "backend",
    "database"
  ],
  "cwe": [
    "CWE-501",
    "CWE-290"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Lateral Movement"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Trust Boundary Confusion - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Authorization check occurs after state mutation",
    "impact": "unauthorized fund transfer"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services",
    "No single point of failure",
    "Distributed system reasoning"
  ],
  "contrastive_pair_id": "PAIR-71378",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to one service",
    "step_1": "Exploit trust assumption in service A",
    "step_2": "Service A forwards request to service B",
    "step_3": "Service B trusts request from A",
    "result": "Lateral movement or privilege escalation"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Requires trust-boundary reasoning",
    "Requires attacker timing",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-AUTH-57269",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "java"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Check if already processed\n    existing = Payment.objects.filter(id=payment_id).first()\n    if existing and existing.status == 'completed':\n        return {\"status\": \"already_processed\"}\n    \n    # Process payment\n    payment = Payment.objects.create(\n        id=payment_id,\n        amount=amount,\n        status='processing'\n    )\n    \n    # Deduct from account\n    account = get_account()\n    account.balance -= amount\n    account.save()\n    \n    payment.status = 'completed'\n    payment.save()\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Idempotency Violation - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-95907",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Exploit spans multiple requests",
    "Requires business context",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-AUTH-70375",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "race_condition_authorization",
  "language": [
    "java"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "api",
    "backend"
  ],
  "cwe": [
    "CWE-362",
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def create_payment_record(user_id, amount):\n    Payment.objects.create(\n        user_id=user_id,\n        amount=amount,\n        status='completed',\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Race Condition Authorization - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-13712",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has account with balance X",
    "step_1": "Initiate multiple concurrent payment requests for amount > X",
    "step_2": "All requests pass balance check simultaneously",
    "step_3": "All requests process, bypassing balance validation",
    "result": "Overdraft or negative balance exploitation"
  },
  "expert_characteristics": [
    "Requires business context",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-RACE-10273",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "python"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Idempotency Violation - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-37314",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-LOGIC-69372",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "privilege_escalation_via_state",
  "language": [
    "javascript"
  ],
  "domain": "authorization",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-269",
    "CWE-284"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "admin.py",
      "role": "mutator",
      "code": "def promote_user(user_id, new_role):\n    user = User.objects.get(id=user_id)\n    \n    # Update role first\n    user.role = new_role\n    user.save()\n    \n    # Then check if current user has permission\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        # Rollback (but already mutated!)\n        user.role = user.previous_role\n        user.save()\n        raise PermissionDenied()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "rbac.py",
      "role": "supporting",
      "code": "def get_current_user():\n    return request.user\n\ndef log_admin_action(admin, action):\n    AdminLog.objects.create(\n        admin=admin,\n        action=action,\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Privilege Escalation Via State - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization check exists",
    "Requires runtime state",
    "State mutation before check",
    "Requires trust-boundary reasoning"
  ],
  "contrastive_pair_id": "PAIR-46154",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has limited user account",
    "step_1": "Trigger privilege change request",
    "step_2": "State mutated before permission check",
    "step_3": "Exploit rollback or race condition",
    "result": "Unauthorized privilege escalation"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Requires business context",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-STATE-60836",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "trust_boundary_confusion",
  "language": [
    "go"
  ],
  "domain": "api_gateway",
  "attack_surface": [
    "api",
    "database"
  ],
  "cwe": [
    "CWE-501",
    "CWE-290"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Lateral Movement"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Trust Boundary Confusion - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services",
    "No single point of failure",
    "Distributed system reasoning"
  ],
  "contrastive_pair_id": "PAIR-32749",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to one service",
    "step_1": "Exploit trust assumption in service A",
    "step_2": "Service A forwards request to service B",
    "step_3": "Service B trusts request from A",
    "result": "Lateral movement or privilege escalation"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-RACE-77232",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "java"
  ],
  "domain": "payment",
  "attack_surface": [
    "service"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Check if already processed\n    existing = Payment.objects.filter(id=payment_id).first()\n    if existing and existing.status == 'completed':\n        return {\"status\": \"already_processed\"}\n    \n    # Process payment\n    payment = Payment.objects.create(\n        id=payment_id,\n        amount=amount,\n        status='processing'\n    )\n    \n    # Deduct from account\n    account = get_account()\n    account.balance -= amount\n    account.save()\n    \n    payment.status = 'completed'\n    payment.save()\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Idempotency Violation - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-45049",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Looks secure in isolation",
    "Requires attacker timing",
    "Requires trust-boundary reasoning"
  ]
}

{
  "sample_id": "VULN-STATE-22468",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "trust_boundary_confusion",
  "language": [
    "python"
  ],
  "domain": "distributed",
  "attack_surface": [
    "api"
  ],
  "cwe": [
    "CWE-501",
    "CWE-290"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Lateral Movement"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Trust Boundary Confusion - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services",
    "No single point of failure",
    "Distributed system reasoning"
  ],
  "contrastive_pair_id": "PAIR-59804",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to one service",
    "step_1": "Exploit trust assumption in service A",
    "step_2": "Service A forwards request to service B",
    "step_3": "Service B trusts request from A",
    "result": "Lateral movement or privilege escalation"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Requires attacker timing",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-AUTH-70221",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "privilege_escalation_via_state",
  "language": [
    "javascript"
  ],
  "domain": "authorization",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-269",
    "CWE-284"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "admin.py",
      "role": "mutator",
      "code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "rbac.py",
      "role": "supporting",
      "code": "def get_current_user():\n    return request.user\n\ndef log_admin_action(admin, action):\n    AdminLog.objects.create(\n        admin=admin,\n        action=action,\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Privilege Escalation Via State - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization check exists",
    "Requires runtime state",
    "State mutation before check",
    "Requires trust-boundary reasoning"
  ],
  "contrastive_pair_id": "PAIR-46154",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has limited user account",
    "step_1": "Trigger privilege change request",
    "step_2": "State mutated before permission check",
    "step_3": "Exploit rollback or race condition",
    "result": "Unauthorized privilege escalation"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Requires business context",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-RACE-94770",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "business_logic_bypass",
  "language": [
    "javascript"
  ],
  "domain": "subscription",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "discount.py",
      "role": "entrypoint",
      "code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
    },
    {
      "snippet_id": "B",
      "file": "cart.py",
      "role": "supporting",
      "code": "def calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    return total"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Business Logic Bypass - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Business logic bypass possible",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def apply_discount(cart, discount_code):\n    discount = Discount.objects.get(code=discount_code)\n    \n    # Check if discount is valid\n    if discount.is_active and discount.valid_until > now():\n        # Check usage limits\n        if discount.usage_count >= discount.max_uses:\n            raise InvalidDiscountError(\"Discount limit reached\")\n        \n        # Check user eligibility\n        if not discount.is_eligible_for_user(cart.user):\n            raise InvalidDiscountError(\"User not eligible\")\n        \n        # Apply discount\n        cart.discount = discount\n        cart.total = calculate_total(cart.items) * (1 - discount.percentage)\n        cart.save()\n        return cart\n    \n    raise InvalidDiscountError()"
  },
  "why_static_analysis_fails": [
    "Requires business context",
    "No syntax errors",
    "Logic appears correct",
    "Requires domain knowledge"
  ],
  "contrastive_pair_id": "PAIR-39012",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to discount codes",
    "step_1": "Apply discount code that appears valid",
    "step_2": "Bypass usage limits or eligibility checks",
    "step_3": "Stack multiple discounts or exploit timing",
    "result": "Unauthorized discount application or financial loss"
  },
  "expert_characteristics": [
    "Requires trust-boundary reasoning",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-STATE-29677",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "race_condition_authorization",
  "language": [
    "java"
  ],
  "domain": "auction",
  "attack_surface": [
    "backend",
    "api"
  ],
  "cwe": [
    "CWE-362",
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def create_payment_record(user_id, amount):\n    Payment.objects.create(\n        user_id=user_id,\n        amount=amount,\n        status='completed',\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Race Condition Authorization - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-75601",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has account with balance X",
    "step_1": "Initiate multiple concurrent payment requests for amount > X",
    "step_2": "All requests pass balance check simultaneously",
    "step_3": "All requests process, bypassing balance validation",
    "result": "Overdraft or negative balance exploitation"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-LOGIC-29589",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "python"
  ],
  "domain": "wallet",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Idempotency Violation - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-68733",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Requires trust-boundary reasoning",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-STATE-78266",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "insecure_deserialization_order",
  "language": [
    "python"
  ],
  "domain": "api",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-502"
  ],
  "owasp_2021": [
    "A08: Software and Data Integrity Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Initial Access",
      "Execution"
    ],
    "technique": [
      "T1203"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Insecure Deserialization Order - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Deserialization looks safe",
    "Validation exists but in wrong order",
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ],
  "contrastive_pair_id": "PAIR-38634",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple requests",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-AUTH-86079",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "trust_boundary_confusion",
  "language": [
    "go"
  ],
  "domain": "distributed",
  "attack_surface": [
    "service"
  ],
  "cwe": [
    "CWE-501",
    "CWE-290"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Lateral Movement"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Trust Boundary Confusion - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": {
    "explanation": "Business logic bypass possible",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services",
    "No single point of failure",
    "Distributed system reasoning"
  ],
  "contrastive_pair_id": "PAIR-39484",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to one service",
    "step_1": "Exploit trust assumption in service A",
    "step_2": "Service A forwards request to service B",
    "step_3": "Service B trusts request from A",
    "result": "Lateral movement or privilege escalation"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Requires runtime state",
    "Exploit spans multiple services",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-STATE-35282",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "state_mutation_before_validation",
  "language": [
    "python"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "database",
    "api"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "State Mutation Before Validation - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires runtime state",
    "Validation exists but in wrong order",
    "State mutation before check",
    "Temporal reasoning required"
  ],
  "contrastive_pair_id": "PAIR-68844",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can trigger state changes",
    "step_1": "Trigger operation that mutates state",
    "step_2": "State changed before validation",
    "step_3": "Validation fails but state persists",
    "result": "Invalid state or unauthorized access"
  },
  "expert_characteristics": [
    "Exploit spans multiple services",
    "Exploit spans multiple requests",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-STATE-26298",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "authorization_order_flaw",
  "language": [
    "python"
  ],
  "domain": "healthcare",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-840",
    "CWE-639"
  ],
  "owasp_2021": [
    "A04: Insecure Design",
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation",
      "Impact"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "transfer.py",
      "role": "mutator",
      "code": "def transfer_funds(from_account, to_account, amount):\n    # Check authorization FIRST\n    if not check_transfer_authorization(from_account, to_account, amount):\n        raise UnauthorizedError()\n    \n    # Then update balance\n    from_account.balance -= amount\n    to_account.balance += amount\n    \n    save_transaction(from_account, to_account, amount)\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "auth.py",
      "role": "validator",
      "code": "def check_transfer_authorization(from_account, to_account, amount):\n    if from_account.balance < amount:\n        return False\n    if from_account.is_frozen:\n        return False\n    return True"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Authorization Order Flaw - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def transfer_funds(from_account, to_account, amount):\n    # Check authorization FIRST\n    if not check_transfer_authorization(from_account, to_account, amount):\n        raise UnauthorizedError()\n    \n    # Then update balance\n    from_account.balance -= amount\n    to_account.balance += amount\n    \n    save_transaction(from_account, to_account, amount)\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization function exists",
    "No missing checks at syntax level",
    "Requires temporal execution reasoning",
    "Order-of-operations vulnerability"
  ],
  "contrastive_pair_id": "PAIR-56115",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has authenticated account with limited balance",
    "step_1": "Initiate transfer request with insufficient funds",
    "step_2": "Balance is mutated before authorization check",
    "step_3": "Authorization fails but state already changed",
    "step_4": "Exploit rollback mechanism or race condition",
    "result": "Unauthorized fund transfer or balance manipulation"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-RACE-19727",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "race_condition_authorization",
  "language": [
    "java"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "service",
    "backend"
  ],
  "cwe": [
    "CWE-362",
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.get(id=user_id)\n    \n    # Check balance\n    if user.balance >= amount:\n        # Race window here - another request can modify balance\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def create_payment_record(user_id, amount):\n    Payment.objects.create(\n        user_id=user_id,\n        amount=amount,\n        status='completed',\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Race Condition Authorization - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-49610",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has account with balance X",
    "step_1": "Initiate multiple concurrent payment requests for amount > X",
    "step_2": "All requests pass balance check simultaneously",
    "step_3": "All requests process, bypassing balance validation",
    "result": "Overdraft or negative balance exploitation"
  },
  "expert_characteristics": [
    "Exploit spans multiple services",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-AUTH-50636",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "insecure_deserialization_order",
  "language": [
    "ruby"
  ],
  "domain": "distributed",
  "attack_surface": [
    "database",
    "api"
  ],
  "cwe": [
    "CWE-502"
  ],
  "owasp_2021": [
    "A08: Software and Data Integrity Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Initial Access",
      "Execution"
    ],
    "technique": [
      "T1203"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Insecure Deserialization Order - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Deserialization looks safe",
    "Validation exists but in wrong order",
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ],
  "contrastive_pair_id": "PAIR-68812",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Looks secure in isolation",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-STATE-79469",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "trust_boundary_confusion",
  "language": [
    "go"
  ],
  "domain": "distributed",
  "attack_surface": [
    "service"
  ],
  "cwe": [
    "CWE-501",
    "CWE-290"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Lateral Movement"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Trust Boundary Confusion - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services",
    "No single point of failure",
    "Distributed system reasoning"
  ],
  "contrastive_pair_id": "PAIR-39484",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to one service",
    "step_1": "Exploit trust assumption in service A",
    "step_2": "Service A forwards request to service B",
    "step_3": "Service B trusts request from A",
    "result": "Lateral movement or privilege escalation"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Requires runtime state",
    "Exploit spans multiple services",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-STATE-34368",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "java"
  ],
  "domain": "payment",
  "attack_surface": [
    "service"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Idempotency Violation - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-45049",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Looks secure in isolation",
    "Requires attacker timing",
    "Requires trust-boundary reasoning"
  ]
}

{
  "sample_id": "VULN-LOGIC-93575",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "python"
  ],
  "domain": "api",
  "attack_surface": [
    "service"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Crypto Timing Attack - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-65957",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-AUTH-16061",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "python"
  ],
  "domain": "wallet",
  "attack_surface": [
    "backend",
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Idempotency Violation - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-13461",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Exploit spans multiple requests",
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-LOGIC-58292",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "java"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "service"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Check if already processed\n    existing = Payment.objects.filter(id=payment_id).first()\n    if existing and existing.status == 'completed':\n        return {\"status\": \"already_processed\"}\n    \n    # Process payment\n    payment = Payment.objects.create(\n        id=payment_id,\n        amount=amount,\n        status='processing'\n    )\n    \n    # Deduct from account\n    account = get_account()\n    account.balance -= amount\n    account.save()\n    \n    payment.status = 'completed'\n    payment.save()\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Idempotency Violation - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": {
    "explanation": "Authorization check occurs after state mutation",
    "impact": "data manipulation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-92196",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Looks secure in isolation",
    "Requires protocol understanding",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-TRUST-77091",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "java"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Idempotency Violation - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-95907",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Exploit spans multiple requests",
    "Requires business context",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-RACE-66206",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "go"
  ],
  "domain": "cryptography",
  "attack_surface": [
    "database"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Crypto Timing Attack - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-35852",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Exploit spans multiple requests",
    "Exploit spans multiple services",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-STATE-10667",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "trust_boundary_confusion",
  "language": [
    "go"
  ],
  "domain": "api_gateway",
  "attack_surface": [
    "api",
    "service"
  ],
  "cwe": [
    "CWE-501",
    "CWE-290"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Lateral Movement"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Trust Boundary Confusion - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services",
    "No single point of failure",
    "Distributed system reasoning"
  ],
  "contrastive_pair_id": "PAIR-64699",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to one service",
    "step_1": "Exploit trust assumption in service A",
    "step_2": "Service A forwards request to service B",
    "step_3": "Service B trusts request from A",
    "result": "Lateral movement or privilege escalation"
  },
  "expert_characteristics": [
    "Exploit spans multiple requests",
    "Requires protocol understanding",
    "Requires trust-boundary reasoning",
    "Looks secure in isolation"
  ]
}

{
  "sample_id": "VULN-RACE-25890",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "crypto_timing_attack",
  "language": [
    "go"
  ],
  "domain": "authentication",
  "attack_surface": [
    "backend"
  ],
  "cwe": [
    "CWE-208",
    "CWE-385"
  ],
  "owasp_2021": [
    "A02: Cryptographic Failures"
  ],
  "mitre_attack": {
    "tactic": [
      "Credential Access"
    ],
    "technique": [
      "T1110"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Crypto Timing Attack - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Cryptographic function exists",
    "Timing differences are subtle",
    "Requires side-channel analysis"
  ],
  "contrastive_pair_id": "PAIR-93341",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has authenticated access",
    "step_1": "Identify vulnerable endpoint",
    "step_2": "Craft malicious request",
    "step_3": "Exploit logic flaw",
    "result": "Unauthorized action or data access"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Exploit spans multiple services",
    "Requires attacker timing",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-RACE-81794",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "state_mutation_before_validation",
  "language": [
    "python"
  ],
  "domain": "banking",
  "attack_surface": [
    "api",
    "backend"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "State Mutation Before Validation - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "transfer funds from another account",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires runtime state",
    "Validation exists but in wrong order",
    "State mutation before check",
    "Temporal reasoning required"
  ],
  "contrastive_pair_id": "PAIR-11185",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can trigger state changes",
    "step_1": "Trigger operation that mutates state",
    "step_2": "State changed before validation",
    "step_3": "Validation fails but state persists",
    "result": "Invalid state or unauthorized access"
  },
  "expert_characteristics": [
    "Requires attacker timing",
    "Exploit spans multiple requests",
    "Requires runtime state"
  ]
}

{
  "sample_id": "VULN-STATE-21814",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "privilege_escalation_via_state",
  "language": [
    "java"
  ],
  "domain": "admin",
  "attack_surface": [
    "database",
    "service"
  ],
  "cwe": [
    "CWE-269",
    "CWE-284"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "admin.py",
      "role": "mutator",
      "code": "def promote_user(user_id, new_role):\n    user = User.objects.get(id=user_id)\n    \n    # Update role first\n    user.role = new_role\n    user.save()\n    \n    # Then check if current user has permission\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        # Rollback (but already mutated!)\n        user.role = user.previous_role\n        user.save()\n        raise PermissionDenied()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "rbac.py",
      "role": "supporting",
      "code": "def get_current_user():\n    return request.user\n\ndef log_admin_action(admin, action):\n    AdminLog.objects.create(\n        admin=admin,\n        action=action,\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Privilege Escalation Via State - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": {
    "explanation": "Race condition in critical section",
    "impact": "privilege escalation"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def promote_user(user_id, new_role):\n    # Check permission FIRST\n    current_user = get_current_user()\n    if not current_user.has_permission('promote_users'):\n        raise PermissionDenied()\n    \n    # Then update role\n    user = User.objects.get(id=user_id)\n    user.role = new_role\n    user.save()\n    \n    log_admin_action(current_user, f\"Promoted {user_id} to {new_role}\")\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization check exists",
    "Requires runtime state",
    "State mutation before check",
    "Requires trust-boundary reasoning"
  ],
  "contrastive_pair_id": "PAIR-45951",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has limited user account",
    "step_1": "Trigger privilege change request",
    "step_2": "State mutated before permission check",
    "step_3": "Exploit rollback or race condition",
    "result": "Unauthorized privilege escalation"
  },
  "expert_characteristics": [
    "Requires business context",
    "Requires trust-boundary reasoning"
  ]
}

{
  "sample_id": "VULN-RACE-28366",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "race_condition_authorization",
  "language": [
    "java"
  ],
  "domain": "auction",
  "attack_surface": [
    "backend",
    "api"
  ],
  "cwe": [
    "CWE-362",
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.get(id=user_id)\n    \n    # Check balance\n    if user.balance >= amount:\n        # Race window here - another request can modify balance\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def create_payment_record(user_id, amount):\n    Payment.objects.create(\n        user_id=user_id,\n        amount=amount,\n        status='completed',\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Race Condition Authorization - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Business logic bypass possible",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-75601",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has account with balance X",
    "step_1": "Initiate multiple concurrent payment requests for amount > X",
    "step_2": "All requests pass balance check simultaneously",
    "step_3": "All requests process, bypassing balance validation",
    "result": "Overdraft or negative balance exploitation"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Exploit spans multiple services"
  ]
}

{
  "sample_id": "VULN-RACE-51091",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "race_condition_authorization",
  "language": [
    "java"
  ],
  "domain": "auction",
  "attack_surface": [
    "service",
    "api"
  ],
  "cwe": [
    "CWE-362",
    "CWE-367"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.get(id=user_id)\n    \n    # Check balance\n    if user.balance >= amount:\n        # Race window here - another request can modify balance\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def create_payment_record(user_id, amount):\n    Payment.objects.create(\n        user_id=user_id,\n        amount=amount,\n        status='completed',\n        timestamp=timezone.now()\n    )"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Race Condition Authorization - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "bypass authorization checks",
  "unsafe_variant": {
    "explanation": "Validation happens after side effects",
    "impact": "unauthorized fund transfer"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "@transaction.atomic\ndef process_payment(user_id, amount):\n    user = User.objects.select_for_update().get(id=user_id)\n    \n    # Check balance with row lock\n    if user.balance >= amount:\n        user.balance -= amount\n        user.save()\n        create_payment_record(user_id, amount)\n        return {\"status\": \"success\"}\n    else:\n        raise InsufficientFundsError()"
  },
  "why_static_analysis_fails": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Concurrency analysis required"
  ],
  "contrastive_pair_id": "PAIR-85814",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has account with balance X",
    "step_1": "Initiate multiple concurrent payment requests for amount > X",
    "step_2": "All requests pass balance check simultaneously",
    "step_3": "All requests process, bypassing balance validation",
    "result": "Overdraft or negative balance exploitation"
  },
  "expert_characteristics": [
    "Looks secure in isolation",
    "Requires trust-boundary reasoning"
  ]
}

{
  "sample_id": "VULN-LOGIC-66936",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "authorization_order_flaw",
  "language": [
    "python"
  ],
  "domain": "healthcare",
  "attack_surface": [
    "service"
  ],
  "cwe": [
    "CWE-840",
    "CWE-639"
  ],
  "owasp_2021": [
    "A04: Insecure Design",
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation",
      "Impact"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "transfer.py",
      "role": "mutator",
      "code": "def transfer_funds(from_account, to_account, amount):\n    # Check authorization FIRST\n    if not check_transfer_authorization(from_account, to_account, amount):\n        raise UnauthorizedError()\n    \n    # Then update balance\n    from_account.balance -= amount\n    to_account.balance += amount\n    \n    save_transaction(from_account, to_account, amount)\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "auth.py",
      "role": "validator",
      "code": "def check_transfer_authorization(from_account, to_account, amount):\n    if from_account.balance < amount:\n        return False\n    if from_account.is_frozen:\n        return False\n    return True"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Authorization Order Flaw - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "api_access"
  ],
  "attacker_goal": "exploit race conditions",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def transfer_funds(from_account, to_account, amount):\n    # Check authorization FIRST\n    if not check_transfer_authorization(from_account, to_account, amount):\n        raise UnauthorizedError()\n    \n    # Then update balance\n    from_account.balance -= amount\n    to_account.balance += amount\n    \n    save_transaction(from_account, to_account, amount)\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization function exists",
    "No missing checks at syntax level",
    "Requires temporal execution reasoning",
    "Order-of-operations vulnerability"
  ],
  "contrastive_pair_id": "PAIR-27307",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has authenticated account with limited balance",
    "step_1": "Initiate transfer request with insufficient funds",
    "step_2": "Balance is mutated before authorization check",
    "step_3": "Authorization fails but state already changed",
    "step_4": "Exploit rollback mechanism or race condition",
    "result": "Unauthorized fund transfer or balance manipulation"
  },
  "expert_characteristics": [
    "Requires attacker timing",
    "Looks secure in isolation",
    "Requires business context"
  ]
}

{
  "sample_id": "VULN-TRUST-60620",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "trust_boundary_confusion",
  "language": [
    "python"
  ],
  "domain": "distributed",
  "attack_surface": [
    "api"
  ],
  "cwe": [
    "CWE-501",
    "CWE-290"
  ],
  "owasp_2021": [
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Lateral Movement"
    ],
    "technique": [
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "main.py",
      "role": "entrypoint",
      "code": "# Code snippet"
    }
  ],
  "data_flow": [
    "A"
  ],
  "vulnerability_description": "Secure implementation: Trust Boundary Confusion - Race condition in critical section",
  "exploit_prerequisites": [
    "authenticated_user",
    "session_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "# Code snippet"
  },
  "why_static_analysis_fails": [
    "Requires trust-boundary reasoning",
    "Exploit spans multiple services",
    "No single point of failure",
    "Distributed system reasoning"
  ],
  "contrastive_pair_id": "PAIR-59804",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker has access to one service",
    "step_1": "Exploit trust assumption in service A",
    "step_2": "Service A forwards request to service B",
    "step_3": "Service B trusts request from A",
    "result": "Lateral movement or privilege escalation"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Requires attacker timing",
    "Requires protocol understanding"
  ]
}

{
  "sample_id": "VULN-RACE-52169",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "idempotency_violation",
  "language": [
    "java"
  ],
  "domain": "fintech_api",
  "attack_surface": [
    "service"
  ],
  "cwe": [
    "CWE-840"
  ],
  "owasp_2021": [
    "A04: Insecure Design"
  ],
  "mitre_attack": {
    "tactic": [
      "Impact"
    ],
    "technique": [
      "T1499"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "payment.py",
      "role": "mutator",
      "code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "account.py",
      "role": "supporting",
      "code": "def get_account():\n    return Account.objects.get(user=request.user)"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Secure implementation: Idempotency Violation - State change before validation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "escalate privileges",
  "unsafe_variant": null,
  "safe_variant": {
    "explanation": "Authorization enforced before state mutation",
    "fix_code": "def process_payment(payment_id, amount):\n    # Use database transaction with unique constraint\n    with transaction.atomic():\n        payment, created = Payment.objects.get_or_create(\n            id=payment_id,\n            defaults={'amount': amount, 'status': 'processing'}\n        )\n        \n        if not created and payment.status == 'completed':\n            return {\"status\": \"already_processed\"}\n        \n        # Process payment\n        account = get_account()\n        account.balance -= amount\n        account.save()\n        \n        payment.status = 'completed'\n        payment.save()\n    \n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Requires protocol understanding",
    "Looks secure in isolation",
    "Exploit spans multiple requests",
    "Idempotency check exists but flawed"
  ],
  "contrastive_pair_id": "PAIR-92196",
  "labels": {
    "ground_truth": "safe",
    "false_negative_risk": "low"
  },
  "exploit_narrative": {
    "attacker_assumption": "attacker can replay requests",
    "step_1": "Initiate payment request",
    "step_2": "Request processed and balance deducted",
    "step_3": "Replay same request before status update",
    "result": "Double charge or balance manipulation"
  },
  "expert_characteristics": [
    "Requires runtime state",
    "Looks secure in isolation",
    "Requires protocol understanding",
    "Requires attacker timing"
  ]
}

{
  "sample_id": "VULN-STATE-44110",
  "difficulty": "expert",
  "vulnerability_type": "logic",
  "vulnerability_subtype": "authorization_order_flaw",
  "language": [
    "python"
  ],
  "domain": "ecommerce",
  "attack_surface": [
    "backend",
    "database"
  ],
  "cwe": [
    "CWE-840",
    "CWE-639"
  ],
  "owasp_2021": [
    "A04: Insecure Design",
    "A01: Broken Access Control"
  ],
  "mitre_attack": {
    "tactic": [
      "Privilege Escalation",
      "Impact"
    ],
    "technique": [
      "T1068",
      "T1078"
    ],
    "subtechnique": null
  },
  "snippets": [
    {
      "snippet_id": "A",
      "file": "transfer.py",
      "role": "mutator",
      "code": "def transfer_funds(from_account, to_account, amount):\n    # Update balance first\n    from_account.balance -= amount\n    to_account.balance += amount\n    \n    # Then check authorization\n    if not check_transfer_authorization(from_account, to_account, amount):\n        # Rollback (but already mutated!)\n        from_account.balance += amount\n        to_account.balance -= amount\n        raise UnauthorizedError()\n    \n    save_transaction(from_account, to_account, amount)\n    return {\"status\": \"success\"}"
    },
    {
      "snippet_id": "B",
      "file": "auth.py",
      "role": "validator",
      "code": "def check_transfer_authorization(from_account, to_account, amount):\n    if from_account.balance < amount:\n        return False\n    if from_account.is_frozen:\n        return False\n    return True"
    }
  ],
  "data_flow": [
    "A -> B -> A"
  ],
  "vulnerability_description": "Authorization Order Flaw - Authorization check after mutation",
  "exploit_prerequisites": [
    "authenticated_user",
    "network_access"
  ],
  "attacker_goal": "manipulate business logic",
  "unsafe_variant": {
    "explanation": "Authorization check occurs after state mutation",
    "impact": "financial loss"
  },
  "safe_variant": {
    "explanation": "Authorization enforced before state change",
    "fix_code": "def transfer_funds(from_account, to_account, amount):\n    # Check authorization FIRST\n    if not check_transfer_authorization(from_account, to_account, amount):\n        raise UnauthorizedError()\n    \n    # Then update balance\n    from_account.balance -= amount\n    to_account.balance += amount\n    \n    save_transaction(from_account, to_account, amount)\n    return {\"status\": \"success\"}"
  },
  "why_static_analysis_fails": [
    "Authorization function exists",
    "No missing checks at syntax level",
    "Requires temporal execution reasoning",
    "Order-of-operations vulnerability"
  ],
  "contrastive_pair_id": "PAIR-90115",
  "labels": {
    "ground_truth": "vulnerable",
    "false_negative_risk": "high"
  },
  "exploit_narrative": {
    "attacker_assumption": "user has authenticated account with limited balance",
    "step_1": "Initiate transfer request with insufficient funds",
    "step_2": "Balance is mutated before authorization check",
    "step_3": "Authorization fails but state already changed",
    "step_4": "Exploit rollback mechanism or race condition",
    "result": "Unauthorized fund transfer or balance manipulation"
  },
  "expert_characteristics": [
    "Requires protocol understanding",
    "Requires runtime state",
    "Requires business context"
  ]
}

